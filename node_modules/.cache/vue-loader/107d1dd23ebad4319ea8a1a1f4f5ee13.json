{"remainingRequest":"/home/tarena/yuying/Learning/Vue3/Vue-Project/mall/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/tarena/yuying/Learning/Vue3/Vue-Project/mall/src/views/detail/Detail.vue?vue&type=style&index=0&id=117d0e76&scoped=true&lang=css&","dependencies":[{"path":"/home/tarena/yuying/Learning/Vue3/Vue-Project/mall/src/views/detail/Detail.vue","mtime":1622267426000},{"path":"/home/tarena/yuying/Learning/Vue3/Vue-Project/mall/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/tarena/yuying/Learning/Vue3/Vue-Project/mall/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/home/tarena/yuying/Learning/Vue3/Vue-Project/mall/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/home/tarena/yuying/Learning/Vue3/Vue-Project/mall/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/tarena/yuying/Learning/Vue3/Vue-Project/mall/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKDQojZGV0YWlsIHsNCiAgcG9zaXRpb246IHJlbGF0aXZlOw0KICB6LWluZGV4OiA5Ow0KICBiYWNrZ3JvdW5kOiAjZmZmOw0KICBoZWlnaHQ6IDEwMHZoOw0KfQ0KLmNvbnRlbnQgew0KICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDQ0cHggLSA0NHB4KTsNCiAgb3ZlcmZsb3c6IGhpZGRlbjsNCn0NCg=="},{"version":3,"sources":["Detail.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Detail.vue","sourceRoot":"src/views/detail","sourcesContent":["<template>\r\n    <div id=\"detail\">\r\n        <detail-nav-bar ref=\"nav\" @clickTitle='clickTitle'></detail-nav-bar>\r\n        <!-- <div>{{$store.state.cartList.length}}</div> 检测是否成功加入购物车 -->\r\n        <!-- <ul>\r\n          <li v-for=\"(item,index) in $store.state.cartList\" :key=\"index\">\r\n            {{item}}\r\n          </li>\r\n        </ul> -->\r\n        <scroll class=\"content\"\r\n        ref='scroll'\r\n        @scroll='contentScroll'\r\n        :probe-type='3'\r\n        :observeImage='true'>\r\n        <!-- 虽然属性名是用的驼峰，但传属性时，用的-分隔，\r\n        因为html标签中不区分大小写，用驼峰topImg命名就相当于topimg，就会找不到\r\n        事件不用，能区分 -->\r\n          <detail-swiper :top-images='topImages'></detail-swiper>\r\n          <detail-base-info :goods='goods'></detail-base-info>\r\n          <detail-shop-info :shop='shop'></detail-shop-info>\r\n          <detail-goods-info :detail-info='detailInfo' @imgLoad='imgLoad'></detail-goods-info>\r\n          <detail-param-info ref=\"params\" :param-info='paramInfo'></detail-param-info>\r\n          <detail-comment-info ref=\"comment\" :comment-info='commentInfo'></detail-comment-info>\r\n          <goods-list ref=\"recommend\" :goods='recommends'></goods-list>\r\n        </scroll>\r\n        <detail-bottom-bar @addCart='addToCart'></detail-bottom-bar>\r\n        <back-top v-show='showTop' @click.native=\"backTop\"></back-top>\r\n        <!-- <toast :message='message' :isShow='isShow'/> -->\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport DetailNavBar from './childComps/DetailNavBar'\r\nimport DetailSwiper from './childComps/DetailSwiper'\r\nimport DetailBaseInfo from './childComps/DetailBaseInfo'\r\nimport DetailShopInfo from './childComps/DetailShopInfo'\r\nimport DetailGoodsInfo from './childComps/DetailGoodsInfo'\r\nimport DetailParamInfo from './childComps/DetailParamInfo'\r\nimport DetailCommentInfo from './childComps/DetailCommentInfo'\r\nimport DetailBottomBar from './childComps/DetailBottomBar'\r\n\r\nimport Scroll from 'components/common/scroll/Scroll'\r\nimport GoodsList from 'components/content/goods/GoodsList'\r\n// import BackTop from 'components/content/backTop/BackTop' 封装进mixin\r\n// import Toast from 'components/common/toast/Toast'\r\n\r\nimport {getDetail,Goods,Shop,GoodsParam,getRecommend} from 'network/detail.js'\r\nimport {debounce} from 'common/utils.js'\r\nimport {itemListenerMixin, backTopMixin} from 'common/mixin.js'\r\nexport default {\r\n  name: 'Detail',\r\n  components: {\r\n    DetailNavBar,\r\n    DetailSwiper,\r\n    DetailBaseInfo,\r\n    DetailShopInfo,\r\n    Scroll,\r\n    DetailGoodsInfo,\r\n    DetailParamInfo,\r\n    DetailCommentInfo,\r\n    GoodsList,\r\n    DetailBottomBar,\r\n    // Toast\r\n  },\r\n  // 利用混合导入了图片加载事件监听，可代替下面mounted中的代码\r\n  // 还可将防抖函数保存在data中，就可使得组件中任意位置都能使用防抖函数\r\n  mixins: [itemListenerMixin, backTopMixin],\r\n  data () {\r\n    return {\r\n      iid: null,\r\n      topImages: [],\r\n      goods: {},\r\n      shop: {},\r\n      detailInfo: {},\r\n      paramInfo: {},\r\n      commentInfo: {},\r\n      recommends: [],\r\n      // itemImgListener: null 通过混入导入\r\n      topYs: [],\r\n      getTopYs: null,\r\n      currentIndex: 0,\r\n      // showTop: false 封装进混入mixin里\r\n      // message: '',\r\n      // isShow: false\r\n    }\r\n  },\r\n  created () {\r\n    // 1.保存传入的id\r\n    this.iid = this.$route.params.iid\r\n    // 2.根据id请求数据\r\n    getDetail(this.iid).then(res => {\r\n      const data = res.result\r\n      // console.log(data);\r\n      // 1.获取顶图的轮播图\r\n      this.topImages = data.itemInfo.topImages\r\n      // 2.获取商品信息\r\n      this.goods = new Goods(data.itemInfo,data.columns,data.shopInfo.services)\r\n      // 3.获取店铺信息\r\n      this.shop = new Shop(data.shopInfo)\r\n      // 4. 获取商品的详细信息\r\n      this.detailInfo = data.detailInfo\r\n      // 5. 获取商品参数信息\r\n      this.paramInfo = new GoodsParam(data.itemParams.info,data.itemParams.rule)\r\n      // 6. 获取评论信息\r\n      if(data.rate.cRate !== 0){\r\n        this.commentInfo = data.rate.list[0]\r\n      }\r\n    })\r\n    // 3. 请求推荐数据\r\n    getRecommend().then(res => {\r\n      // console.log(res);\r\n      this.recommends = res.data.list\r\n    })\r\n    // this.$nextTick(() => { // 下一帧，此函数会等到组件dom渲染完后再调用，但组件中的图片并不一定加载完全\r\n    //   this.topYs = []  // 得到的offsetTop值不准确，大多数都是因为图片未加载的问题\r\n    //   this.topYs.push(0)\r\n    //   this.topYs.push(this.$refs.params.$el.offsetTop)\r\n    //   this.topYs.push(this.$refs.comment.$el.offsetTop)\r\n    //   this.topYs.push(this.$refs.recommend.$el.offsetTop)\r\n    // })\r\n    // 4. 为topYs设置防抖\r\n    this.getTopYs = debounce(() => {\r\n      this.topYs = []\r\n      this.topYs.push(0)\r\n      this.topYs.push(this.$refs.params.$el.offsetTop)\r\n      this.topYs.push(this.$refs.comment.$el.offsetTop)\r\n      this.topYs.push(this.$refs.recommend.$el.offsetTop)\r\n      this.topYs.push(Number.MAX_VALUE) // 在数组末尾增加一个无限大的值，为了之后对数组做遍历\r\n      console.log(this.topYs)\r\n    },100)\r\n  },\r\n  mounted () {\r\n    // 利用mixin混入后，代替了下面的代码\r\n      // const refresh = debounce(this.$refs.scroll.refresh,50)\r\n      // this.itemImgListener = () => { refresh() }\r\n      // // 在此组件中监听itemImageLoad图片加载事件\r\n      // this.$bus.$on('itemImageLoad', this.itemImgListener)\r\n      // this.topYs = []  // 刷新，否则会重复添加进入\r\n      // this.topYs.push(0)\r\n      // this.topYs.push(this.$refs.params.$el.offsetTop) // 获取到参数组件元素$el的offsetTop\r\n      // this.topYs.push(this.$refs.comment.$el.offsetTop)\r\n      // this.topYs.push(this.$refs.recommend.$el.offsetTop)\r\n      // console.log(this.topYs);  // mounted()中未得到数据\r\n    },\r\n    updated () {\r\n      // 在得到数据后会执行updated，对页面进行更新，只要数据变化就会更新\r\n      // 获得的offsetTop值也不准确\r\n      // this.topYs = []  // 刷新，否则会重复添加进入\r\n      // this.topYs.push(0)\r\n      // this.topYs.push(this.$refs.params.$el.offsetTop) // 获取到参数组件元素$el的offsetTop\r\n      // this.topYs.push(this.$refs.comment.$el.offsetTop)\r\n      // this.topYs.push(this.$refs.recommend.$el.offsetTop)\r\n      // console.log(this.topYs);\r\n    },\r\n  destroyed () {\r\n    // 离开组件时取消图片加载监听事件\r\n    this.$bus.$off('itemImageLoad', this.itemImgListener)\r\n  },\r\n  methods: {\r\n    imgLoad () {\r\n      // console.log('/////'); 老师这里会刷新多次，但我这里只刷新一次\r\n      this.$refs.scroll.refresh()\r\n      this.getTopYs()\r\n      // this.topYs = []\r\n      // this.topYs.push(0)\r\n      // this.topYs.push(this.$refs.params.$el.offsetTop)\r\n      // this.topYs.push(this.$refs.comment.$el.offsetTop)\r\n      // this.topYs.push(this.$refs.recommend.$el.offsetTop)\r\n      // console.log('=====') //老师这里会刷新多次，但我这里只刷新一次\r\n    },\r\n    clickTitle (index) {\r\n      // console.log(index);\r\n      this.$refs.scroll.scrollTo(0,-this.topYs[index],1000)\r\n    },\r\n    contentScroll (position) { // 根据scroll组件发出的scroll事件，获取到position值\r\n    // 1.获取y值\r\n      const positionY = - position.y\r\n      // 2.将y值与组件内容高度做对比\r\n      // console.log(this.topYs[0]); // 这里是undefined，得不到它的值，并且即使得到了也应该为负值，\r\n      // console.log(positionY);\r\n      let length = this.topYs.length\r\n      // for(let i in this.topYs)  此方法获取的 i为字符串 要用parseInt(i) 或者 i*1 的方法将其转为数值\r\n      // for(let i=0;i<length;i++){\r\n        // if(this.topYs[i].positionY >=0 && this.topYs[i].positionY < this.topYs[i+1].positionY)\r\n      //   console.log(this.topYs[i]);\r\n      // console.log(this.topYs.length);\r\n      // 1.普通做法\r\n        // if(this.currentIndex !== i && ((i < length -1 && positionY >= this.topYs[i] && positionY < this.topYs[i+1]) || (i === length -1 && positionY >= this.topYs[i]))){\r\n        // 2.hack做法，在数组后面加一个无限大的值，并且遍历时只遍历到 i<length-1\r\n        for(let i=0;i<length-1;i++){\r\n          if(this.currentIndex !== i && (i<length-1 && positionY >= this.topYs[i] && positionY < this.topYs[i+1])){\r\n            this.currentIndex = i\r\n          console.log(i); // 因为此时打印非常频繁，所以将当前index保存为一个变量，在两个不等的情况下才打印，就不会很频繁\r\n          console.log(this.topYs[i]); // 此处的值是正值\r\n          this.$refs.nav.currentIndex = this.currentIndex\r\n        }\r\n      }\r\n      // 是否显示回到底部按钮的判断\r\n      this.showTop = positionY > 1000\r\n    },\r\n    // 封装到混入mixin里\r\n      // backTop () {\r\n      //   this.$refs.scroll.scrollTo(0,0)\r\n      // }\r\n    addToCart () {\r\n      // 1.获取购物车需要展示的信息，因为有多个信息，所以可以放在一个对象里\r\n      const product = {}\r\n      product.image = this.topImages[0]\r\n      product.title = this.goods.title\r\n      product.desc = this.goods.desc\r\n      product.price = this.goods.realPrice\r\n      product.iid = this.iid // id一定要传，因为id是商品的唯一标识，是将id传给服务器获取到对应的商品\r\n\r\n      // 2.将商品添加到购物车里\r\n      // this.$store.commit('addCart',product) commit是将product提交到store中mutations里的方法addCart\r\n      this.$store.dispatch('addCart',product)  // dispatch是提交到actions里去，再由actions分发commit到mutations里不同的方法中去\r\n      // 3.如果添加购物车成功（用promise监视成功与否）\r\n      .then(res => {\r\n        // console.log(res);\r\n        // this.isShow = true\r\n        // this.message = res\r\n        // setTimeout(() => {\r\n        //   this.isShow = false\r\n        // },1000)\r\n        this.$toast.show(res,1000)\r\n      })\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n#detail {\r\n  position: relative;\r\n  z-index: 9;\r\n  background: #fff;\r\n  height: 100vh;\r\n}\r\n.content {\r\n  height: calc(100% - 44px - 44px);\r\n  overflow: hidden;\r\n}\r\n</style>\r\n"]}]}